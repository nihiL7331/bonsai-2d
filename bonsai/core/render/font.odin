package render

import io "bonsai:core/platform"
import sg "bonsai:libs/sokol/gfx"
import tt "bonsai:libs/stb/truetype"
import game "bonsai:types/game"
import "bonsai:types/gmath"

import "core:fmt"
import "core:log"
import "core:strings"

// size constraints for each fonts bitmap
BITMAP_WIDTH :: 512
BITMAP_HEIGHT :: 512

Font :: struct {
	texture:  sg.Image,
	view:     sg.View, // we need to store a view for drawing
	charData: [96]tt.bakedchar,
	name:     string, // id for a font
}

@(private)
_fontCache: map[string]Font

getFont :: proc(fontId: game.FontName, size: uint) -> (Font, bool) {
	if fontId == .nil {
		log.error("Got .nil font id.")
		return {}, false
	}

	name := fmt.tprintf("%v", fontId)
	key := fmt.tprintf("%s_%d", name, size)

	if key in _fontCache {
		setFontTexture(_fontCache[key].view)
		return _fontCache[key], true
	}

	// we use the autogenerated data via the CLI.
	// fontFilename is a map to directories in which font files live
	filename := game.fontFilename[fontId]
	path := fmt.tprintf("assets/fonts/%s", filename)

	// io.read_entire_file is a platform-agnostic implementation of
	// os.read_entire_file, it works on web too
	ttfData, success := io.read_entire_file(path)
	if !success {
		log.errorf("Could not find file for font ID: %v.", fontId)
		return {}, false
	}
	defer delete(ttfData)

	bitmap := make([]u8, BITMAP_WIDTH * BITMAP_HEIGHT)
	defer delete(bitmap)

	font := Font {
		name = strings.clone(name),
	}

	ret := tt.BakeFontBitmap(
		raw_data(ttfData),
		0,
		f32(size),
		raw_data(bitmap),
		BITMAP_WIDTH,
		BITMAP_HEIGHT,
		32,
		96,
		&font.charData[0],
	)
	if ret <= 0 {
		log.errorf("Bitmap is too small for selected font ID: %v, size: %v.", fontId, size)
		return {}, false
	}

	description := sg.Image_Desc {
		width        = BITMAP_WIDTH,
		height       = BITMAP_HEIGHT,
		pixel_format = .R8,
		label        = "font_texture",
	}
	description.data.subimage[0][0] = {
		ptr  = raw_data(bitmap),
		size = len(bitmap),
	}

	// store the image just for cleanup purposes
	// its just 4 bytes (u32) anyway
	font.texture = sg.make_image(description)
	if font.texture.id == sg.INVALID_ID {
		log.errorf("Failed to create an image for font ID %v.", fontId)
		return {}, false
	}

	font.view = sg.make_view({texture = sg.Texture_View_Desc{image = font.texture}})
	if font.view.id == sg.INVALID_ID {
		log.errorf("Failed to create a view for font ID %v.", fontId)
		return {}, false
	}

	setFontTexture(font.view)

	// cache the font data so that it doesnt have to regenerate each frame
	_fontCache[strings.clone(key)] = font

	return font, true
}

// get width of unwrapped text given font and font size
getTextSize :: proc(fontId: game.FontName, fontSize: uint, text: string) -> gmath.Vec2 {
	font, found := getFont(fontId, fontSize)
	if !found {
		return gmath.Vec2{0, 0}
	}

	currentWidth: f32 = 0
	maxWidth: f32 = 0
	lines: f32 = 1

	startChar :: 32
	charCount :: 96

	for textChar in text {
		if textChar == '\n' {
			if currentWidth > maxWidth {
				maxWidth = currentWidth
			}
			currentWidth = 0
			lines += 1
			continue
		}

		index := int(textChar) - startChar
		if index < 0 || index >= charCount do continue // not ascii

		currentWidth += font.charData[index].xadvance
	}

	if currentWidth > maxWidth {
		maxWidth = currentWidth
	}

	totalHeight := lines * f32(fontSize)

	return gmath.Vec2{maxWidth, totalHeight}
}

destroyFonts :: proc() {
	for key, font in _fontCache {
		sg.destroy_image(font.texture)
		sg.destroy_view(font.view)
		delete(font.name)
		delete(key)
	}
	delete(_fontCache)
}
