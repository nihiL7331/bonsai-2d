package render

import "bonsai:core/gmath"
import "bonsai:core/platform"
import "bonsai:generated"

import sokol_gfx "bonsai:libs/sokol/gfx"
import stb_truetype "bonsai:libs/stb/truetype"

import "core:fmt"
import "core:log"
import "core:strings"

@(private = "file")
_fontCache: map[string]Font

// @ref
// Retrieves or loads a font for a specific size.
// **Caches** the result to avoid re-baking the bitmap every frame.
getFont :: proc(fontName: generated.FontName, size: uint) -> (Font, bool) {
	if fontName == .nil {
		log.error("Got .nil font name.")
		return {}, false
	}

	// create a unique cache key: "FontName_Size"
	// e.g. "PixelCode_12"
	nameString := fmt.tprintf("%v", fontName)
	cacheKey := fmt.tprintf("%s_%d", nameString, size)

	if cacheKey in _fontCache {
		cachedFont := _fontCache[cacheKey]
		setFontTexture(cachedFont.view)
		return cachedFont, true
	}

	// we use the autogenerated data via the CLI.
	// fontFilename is a map to directories in which font files live
	path := generated.fontFilename[fontName]

	fontFileData, success := platform.read_entire_file(path)
	if !success {
		log.errorf("Could not find file for font name: %v.", fontName)
		return {}, false
	}
	defer delete(fontFileData)

	bitmap := make([]u8, BITMAP_WIDTH * BITMAP_HEIGHT)
	defer delete(bitmap)

	font := Font {
		name = strings.clone(nameString),
	}

	rowsBaked := stb_truetype.BakeFontBitmap(
		raw_data(fontFileData),
		0,
		f32(size),
		raw_data(bitmap),
		BITMAP_WIDTH,
		BITMAP_HEIGHT,
		32,
		96,
		&font.characterData[0],
	)

	if rowsBaked <= 0 {
		log.errorf("Bitmap is too small for selected font name: %v, size: %v.", fontName, size)
		return {}, false
	}

	imageDescription := sokol_gfx.Image_Desc {
		width        = BITMAP_WIDTH,
		height       = BITMAP_HEIGHT,
		pixel_format = .R8,
		label        = "font_texture",
	}
	imageDescription.data.subimage[0][0] = {
		ptr  = raw_data(bitmap),
		size = len(bitmap),
	}

	font.texture = sokol_gfx.make_image(imageDescription)
	if font.texture.id == sokol_gfx.INVALID_ID {
		log.errorf("Failed to create an image for font name %v.", fontName)
		return {}, false
	}

	font.view = sokol_gfx.make_view({texture = sokol_gfx.Texture_View_Desc{image = font.texture}})
	if font.view.id == sokol_gfx.INVALID_ID {
		log.errorf("Failed to create a view for font name %v.", fontName)
		return {}, false
	}

	setFontTexture(font.view)

	// store in cache
	_fontCache[strings.clone(cacheKey)] = font

	return font, true
}

// @ref
// Calculates the total dimension **(width, height)** of a string if it were rendered.
// :::tip
// Useful for centering text.
// :::
getTextSize :: proc(fontName: generated.FontName, fontSize: uint, text: string) -> gmath.Vector2 {
	font, found := getFont(fontName, fontSize)
	if !found {
		return gmath.Vector2{0, 0}
	}

	currentLineWidth: f32 = 0
	maxLineWidth: f32 = 0
	lineCount: f32 = 1

	START_CHAR :: 32
	CHAR_COUNT :: 96

	for character in text {
		if character == '\n' {
			if currentLineWidth > maxLineWidth {
				maxLineWidth = currentLineWidth
			}
			currentLineWidth = 0
			lineCount += 1
			continue
		}

		index := int(character) - START_CHAR

		if index < 0 || index >= CHAR_COUNT do continue // not ascii

		currentLineWidth += font.characterData[index].xadvance
	}

	if currentLineWidth > maxLineWidth {
		maxLineWidth = currentLineWidth
	}

	//NOTE: this is just an approximation
	totalHeight := lineCount * f32(fontSize)

	return gmath.Vector2{maxLineWidth, totalHeight}
}

// Cleans up all GPU resources associated with loaded fonts.
//
// Is called on application shutdown from main.odin.
destroyFonts :: proc() {
	for key, font in _fontCache {
		sokol_gfx.destroy_image(font.texture)
		sokol_gfx.destroy_view(font.view)
		delete(font.name)
		delete(key)
	}
	delete(_fontCache)
}
