package ldtk

import "core:encoding/json"
import "core:log"
import "core:mem"
import "core:strings"

import io "../../core/platform"
import "../../types/gmath"
import type "type"

@(private)
_arenaBuffer: []byte
@(private)
_arena: mem.Arena

// parses JSON file of a project from an enum auto-generated by the cli
loadData :: proc(name: type.WorldName) -> bool {
	if name == type.WorldName.nil {
		log.error("nil world can't be loaded.")
		return false
	}

	if len(_arenaBuffer) == 0 {
		_arenaBuffer = make([]byte, 16 * 1024 * 1024) // 16MB
		mem.arena_init(&_arena, _arenaBuffer)
	} else {
		mem.arena_free_all(&_arena)
	}

	path := type.worldFilename[name]
	bytes, success := io.read_entire_file(path)
	if !success {
		log.errorf("Failed to read world file: %v.", name)
		return false
	}
	defer delete(bytes)

	context.allocator = mem.arena_allocator(&_arena)

	error := json.unmarshal(bytes, &_world)
	if error != nil {
		log.errorf("JSON parsing error for %v: %v", path, error)
		return false
	}

	return true
}

// calls all functions that take LDtk data and converts them to more useful forms
generateData :: proc() {
	context.allocator = mem.arena_allocator(&_arena)
	calculateWorldPosition() // generates a worldPosition variable for all objects that have rawWorldX and rawWorldY, which holds the px position regardless of world layout, relative to world center
	generateEntityHashmap() // generates a O(1) lookup for entities through auto-generated LDtk unique identifiers assigned to every EntityInstance
	generateWorldColliders() // generates colliders variable for every level, it holds gmath.Rects that can be used to make simple colliders
	generateEntityCustomFields() // generates hashmaps from entity custom fields, that can be later read by an entity system
}

unloadData :: proc() {
	mem.arena_free_all(&_arena)
	delete(_arenaBuffer)
}

calculateWorldPosition :: proc() {
	worldPosition := gmath.Vec2Int{0, 0}
	for &level in _world.levels {
		if _world.worldLayout == type.WorldLayout.Free ||
		   _world.worldLayout == type.WorldLayout.GridVania {
			level.worldPosition = gmath.Vec2Int{level.rawWorldX, -level.rawWorldY}
			calculateWorldEntityPosition(level)
			continue
		}

		level.worldPosition = worldPosition
		calculateWorldEntityPosition(level)


		if _world.worldLayout == type.WorldLayout.LinearHorizontal do worldPosition += gmath.Vec2Int{level.pxWidth, 0}
		else if _world.worldLayout == type.WorldLayout.LinearVertical do worldPosition -= gmath.Vec2Int{0, level.pxHeight}
	}
}

calculateWorldEntityPosition :: proc(level: type.Level) {
	layers, ok := level.layerInstances.?
	if ok {
		for layer in layers {
			entities := layer.entityInstances
			if len(entities) == 0 do continue

			for &entity in entities {
				entity.worldPosition = gmath.Vec2Int {
					level.worldPosition.x + entity.pxPosition[0],
					level.worldPosition.y + level.pxHeight - entity.pxPosition[1],
				}
			}
		}
	}
}

generateWorldColliders :: proc() {
	for &level in _world.levels {
		colliders := make([dynamic]gmath.Rect)

		layers, ok := level.layerInstances.?
		if !ok {
			level.colliders = colliders
			continue
		}

		grid: [dynamic]int
		gridWidth: int
		gridHeight: int
		gridSize: f32

		found := false
		for layer in layers {
			if layer.type == "IntGrid" && layer.identifier == type.COLLISIONS_LAYER_IDENTIFIER {
				grid = layer.intGrid
				gridWidth = layer.gridWidth
				gridHeight = layer.gridHeight
				gridSize = f32(layer.gridSize)
				found = true
				break
			}
		}
		if !found || len(grid) == 0 {
			level.colliders = colliders
			continue
		}

		for y := 0; y < gridHeight; y += 1 {
			startX := -1

			for x := 0; x < gridWidth; x += 1 {
				index := y * gridWidth + x
				value := grid[index]

				isWall := (value == type.INTGRID_WALL_VALUE)
				if isWall && startX == -1 do startX = x
				else if !isWall && startX != -1 {
					position := gmath.Vec2{f32(level.worldPosition.x) + f32(startX) * gridSize, f32(level.worldPosition.y) - f32(y + 1 - gridHeight) * gridSize}
					size := gmath.Vec2{f32(x - startX) * gridSize, gridSize}
					// size := gmath.Vec2{8.0, 8.0}
					rect := gmath.rectMake(position, size)
					append(&colliders, rect)
					startX = -1
				}
			}
			// if row has finished and didn't create the collider yet
			if startX != -1 {
				position := gmath.Vec2 {
					f32(level.worldPosition.x) + f32(startX) * gridSize,
					f32(level.worldPosition.y) - f32(y + 1 - gridHeight) * gridSize,
				}
				size := gmath.Vec2{f32(gridWidth - startX) * gridSize, gridSize}
				rect := gmath.rectMake(position, size)
				append(&colliders, rect)
			}
		}

		level.colliders = colliders
	}
}

generateEntityHashmap :: proc() {
	for level in _world.levels {
		layers, ok := level.layerInstances.?
		if !ok do continue
		for layer in layers {
			if layer.type != "Entities" do continue
			for &entity in layer.entityInstances {
				_world.entities[entity.iid] = &entity
			}
		}
	}
}

generateEntityCustomFields :: proc() {
	for level in _world.levels {
		if layers, ok := level.layerInstances.?; ok {
			for layer in layers {
				for &entity in layer.entityInstances {
					entity.customFields = make(map[string]type.FieldInstanceType)
					for field in entity.fieldInstances {
						if value, valueOk := getField(field, level); valueOk {
							log.infof("Loaded value: %v", value)
							key := strings.clone(field.identifier)
							entity.customFields[key] = value
						}
					}
				}
			}
		}
	}
}
